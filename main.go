//
// Copyright 2020 Alexander Saastamoinen
//
//  Licensed under the EUPL, Version 1.2 or â€“ as soon they
// will be approved by the European Commission - subsequent
// versions of the EUPL (the "Licence");
//  You may not use this work except in compliance with the
// Licence.
//  You may obtain a copy of the Licence at:
//
//  https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
//
//  Unless required by applicable law or agreed to in
// writing, software distributed under the Licence is
// distributed on an "AS IS" basis,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied.
//  See the Licence for the specific language governing
// permissions and limitations under the Licence.
//

package main

import (
	"archive/tar"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sync"
	"unicode/utf8"
)

const (
	usage       string = "embed [path(0)]... [path(i)]// embed path dir or file/s into current pwd package"
	tarReminder string = "//variable contains a tar archive"
	preTemplate string = `package %s

//autogenerated by embed

%s
func %s() []byte {
	var bindata = []byte{`

	postTemplate string = `}
	return bindata
}`
)

var ()

func findPackageName() (name string, err error) {
	fset := token.NewFileSet()
	fMap, err := parser.ParseDir(fset, ".", nil, parser.PackageClauseOnly)
	if err != nil {
		return
	}
	if len(fMap) != 1 {
		err = errors.New("expected only one package in current directory, found: " + string(len(fMap)))
		return
	}
	for k := range fMap {
		if k == "" {
			err = errors.New("current pwd package has empty name")
			return
		}
		name = k
	}
	return name, nil
}

func (m *Maker) OpenFiles(paths []string) (files []*os.File) {
	out := make(chan *[]*os.File)
	var wg sync.WaitGroup
	for _, p := range paths {
		wg.Add(1)
		go m.parsePath(p, out, &wg)
	}
	go func() {
		wg.Wait()
		close(out)
	}()
	for fs := range out {
		files = append(files, *fs...)
	}
	return
}

type Maker struct {
	SkipDir     bool
	ParseHidden bool
	Recurssive  bool
	isTar       bool
}

func (m *Maker) parsePath(p string, out chan *[]*os.File, wg *sync.WaitGroup) {
	defer wg.Done()
	var files []*os.File
	if err := filepath.Walk(p, func(path string, info os.FileInfo, err error) error {
		if path == p && info.IsDir() { //skip root if dir
			return nil
		}
		if !m.ParseHidden {
			if r, _ := utf8.DecodeRuneInString(info.Name()); string(r) == "." {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}
		if !m.Recurssive {
			if info.IsDir() {
				return filepath.SkipDir
			}
		}
		if m.SkipDir {
			if info.IsDir() {
				return nil
			}
		}
		f, err := os.Open(path)
		if err != nil {
			return err
		}
		files = append(files, f)
		return nil
	}); err != nil {
		log.Panic(err)
	}
	out <- &files
}

func (m *Maker) MakeTar(files []*os.File) *bytes.Buffer {
	buf := new(bytes.Buffer)
	if len(files) == 1 {
		log.Println("only 1 file found, skipping tar archiving")
		// skip tar process if only one file
		_, err := io.Copy(buf, files[0])
		if err != nil {
			log.Panic(err)
		}
		return buf
	}
	m.isTar = true

	tw := tar.NewWriter(buf)
	for _, f := range files {
		fi, err := f.Stat()
		if err != nil {
			log.Panic(err)
		}
		head, err := tar.FileInfoHeader(fi, "")
		if err != nil {
			log.Panic(err)
		}
		if err := tw.WriteHeader(head); err != nil {
			log.Panic(err)
		}
		if !fi.IsDir() {
			if _, err := io.Copy(tw, f); err != nil {
				log.Panic(err)
			}
		}
		f.Close()
	}
	if err := tw.Close(); err != nil {
		log.Panic(err)
	}
	return buf
}

func (m *Maker) MakeSource(rawBuf *bytes.Buffer, packageName string, funcName string) *bytes.Buffer {
	buf := new(bytes.Buffer)
	isTarStr := ""
	if m.isTar {
		isTarStr = tarReminder
	}

	_, err := fmt.Fprintf(buf, preTemplate, packageName, isTarStr, funcName)
	if err != nil {
		log.Panic(err)
	}

	raw, err := ioutil.ReadAll(rawBuf)
	if err != nil {
		log.Panic(err)
	}
	for _, b := range raw {
		fmt.Fprintf(buf, "%#v, ", b)
	}

	if _, err = fmt.Fprint(buf, postTemplate); err != nil {
		log.Panic(err)
	}

	return buf
}

func main() {
	m := new(Maker)
	// set flags:
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s [options] [path0] ... [pathi]\nGenerates a go source file for golang package in current directory containing all files found in given paths. Accessed through 'func bindata() []byte'. If multiple paths or path is a directory files will be packed into a tar archive.\n\nOptions:\n", os.Args[0])
		flag.PrintDefaults()
	}
	funcName := flag.String("name", "bindata", "sets generated source files data holding variable name, def bindata. Also sets fname to name + '.go'")
	packageName := flag.String("pname", "", "sets generated source files package name instead of parsing from current directories package")
	fileName := flag.String("fname", "bindata.go", "sets generated source files name, default is bindata.go, use this to avoid overwritting")
	flag.BoolVar(&m.SkipDir, "skipdir", false, "directories are not added to outputed tar archive")
	flag.BoolVar(&m.ParseHidden, "phidden", false, "also encode hidden files.")
	flag.BoolVar(&m.Recurssive, "r", false, "walk recurssively path")
	flag.Parse()

	if *packageName == "" {
		if name, err := findPackageName(); err != nil {
			log.Println("embed failed to find a package name to attach data to, quitting")
			log.Panic(err)
		} else {
			*packageName = name
		}
	}
	flag.Visit(func(f *flag.Flag) {
		if f.Name == "name" {
			*fileName = f.Value.String() + ".go"
		}
	})

	paths := flag.Args()
	files := m.OpenFiles(paths)
	tarBuf := m.MakeTar(files)
	sourceFileBuff := m.MakeSource(tarBuf, *packageName, *funcName)
	file, err := os.OpenFile(*fileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0664)
	if err != nil {
		log.Panic(err)
	}
	defer file.Close()
	_, err = sourceFileBuff.WriteTo(file)
	if err != nil {
		log.Panic(err)
	}
	fmt.Printf("created %s for package %s containing:\n", *fileName, *packageName)
	fmt.Println(paths)
}
